package io.composeflow.ksp

import kotlinx.serialization.json.Json
import kotlinx.serialization.decodeFromString
import java.io.File

/**
 * Utility class to load LLM tool definitions generated by the KSP processor.
 */
class LlmToolsLoader {
    private val json = Json { 
        ignoreUnknownKeys = true
        prettyPrint = true
    }
    
    /**
     * Load all LLM tool definitions from the specified directory.
     * 
     * @param directory The directory containing the generated JSON files.
     * @return A list of LlmToolInfo objects.
     */
    fun loadTools(directory: File): List<LlmToolInfo> {
        if (!directory.exists() || !directory.isDirectory) {
            return emptyList()
        }
        
        return directory.listFiles { file -> file.extension == "json" }
            ?.mapNotNull { file ->
                try {
                    json.decodeFromString<LlmToolInfo>(file.readText())
                } catch (e: Exception) {
                    null
                }
            } ?: emptyList()
    }
    
    /**
     * Convert LLM tool definitions to a format suitable for use with OpenAI's function calling API.
     * 
     * @param tools The list of LlmToolInfo objects.
     * @return A list of maps representing the tools in OpenAI's function format.
     */
    fun convertToOpenAIFormat(tools: List<LlmToolInfo>): List<Map<String, Any>> {
        return tools.map { tool ->
            mapOf(
                "type" to "function",
                "function" to mapOf(
                    "name" to tool.name,
                    "description" to tool.description,
                    "parameters" to mapOf(
                        "type" to "object",
                        "properties" to tool.parameters.associate { param ->
                            param.name to mapOf(
                                "type" to convertKotlinTypeToJsonType(param.type),
                                "description" to param.description
                            )
                        },
                        "required" to tool.parameters.filter { it.required }.map { it.name }
                    )
                )
            )
        }
    }
    
    /**
     * Convert LLM tool definitions to a format suitable for use with Claude's API.
     * 
     * @param tools The list of LlmToolInfo objects.
     * @return A list of maps representing the tools in Claude's format.
     */
    fun convertToClaudeFormat(tools: List<LlmToolInfo>): Map<String, Any> {
        val toolsList = tools.map { tool ->
            mapOf(
                "name" to tool.name,
                "description" to tool.description,
                "input_schema" to mapOf(
                    "type" to "object",
                    "properties" to tool.parameters.associate { param ->
                        param.name to mapOf(
                            "type" to convertKotlinTypeToJsonType(param.type),
                            "description" to param.description
                        )
                    },
                    "required" to tool.parameters.filter { it.required }.map { it.name }
                )
            )
        }
        
        // Return the tools wrapped in a "tools" key
        return mapOf("tools" to toolsList)
    }
    
    /**
     * Convert Kotlin types to JSON schema types.
     */
    private fun convertKotlinTypeToJsonType(kotlinType: String): String {
        // Check if the type is a fully qualified name or a simple name
        val simpleName = kotlinType.substringAfterLast('.')
        
        return when {
            kotlinType.contains("String") || simpleName == "String" -> "string"
            kotlinType.contains("Int") || simpleName == "Int" ||
            kotlinType.contains("Long") || simpleName == "Long" -> "integer"
            kotlinType.contains("Float") || simpleName == "Float" ||
            kotlinType.contains("Double") || simpleName == "Double" -> "number"
            kotlinType.contains("Boolean") || simpleName == "Boolean" -> "boolean"
            kotlinType.contains("List") || simpleName == "List" ||
            kotlinType.contains("Array") || simpleName == "Array" -> "array"
            // For custom types, use "object" type
            else -> "object"
        }
    }
}